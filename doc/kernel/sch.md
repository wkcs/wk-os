# 调度器

## 1、调度器的任务
* 该操作系统是一个基于优先级的硬实时操作系统，支持最多256个优先级（0-255），最少8个优先级（0-7），同时也支持多个相同优先级的任务。因此该调度器主要实现了两种调度方式，一种是针对不同优先级任务，基于优先级的调度方式，还有一种是针对相同优先级任务的时间片轮转调度方式。
* 对于不同优先级的任务，调度器总是让处于高优先级的任务占有CPU，一旦有更高优先级的任务就绪，调度器会立即让当前任务让出CPU，然后让更高优先级的任务去运行。
* 对于相同优先级的任务，调度器会让处于该优先级的任务轮流执行，至于轮流的时间则由任务初始化时设置的时间片来决定。每个任务用完自己的时间片以后，就会将CPU让给其他同等优先级的任务。

## 2、基于优先级调度的原理
* 调度器维护了一个就绪任务表**ready_task_list**，该就绪任务表一共有8级（此处以支持8个优先级的调度器为例），分别对应着0-7的优先级，就绪任务表的每一级记录着该优先级的所有就绪任务，每当需要进行任务调度的时候，调度器就会查找该就绪任务表，来找到当前最高优先级的就绪任务，并让该任务开始运行。
* 调度器为了能够以最快的速度找到最高优先级的任务，并没有采用遍历就绪任务表的方式，而是为就需任务表设置了一个8位的掩码（256个优先级使用的原理基本相同），通过该掩码来查找最高优先级就绪任务（遍历的方式会随着任务的增多而增加调度时间，这是硬实时操作系统所不允许的），这样可以保证每次调度使用的时间都是一样的，时间复杂度为O(1)。
该掩码的每一位对应着每一个优先级，当该优先级存在就绪任务时，掩码的对应位就会被设置为1，例如优先级0存在就绪任务，那么该掩码的第0位就会被设置为1。然后通过__wk_ffs函数就可以在固定的时间内快速找出存在就绪任务的最高优先级（__wk_ffs函数针对不同的硬件平台所使用的方法不同。例如ARM平台已经提供了相应的指令，可以直接调用该指令完成，而对于没有硬件指令的平台则是使用查找位图的方式实现）。

## 3、时间片轮转调度原理
* 时间片轮转调度针对的是相同优先级的任务，系统中具有相同优先级的就绪任务会以一个双向链表的形式被组织起来（与linux使用的双向链表相同），然后将表头放在就绪任务表的对应优先级上。调度器会在每个系统节拍将当前任务的剩余时间片减1，如果当前任务的剩余时间片为0，则将将CPU让给该任务所在就绪任务链表的下一个任务，并将该任务的剩余时间品重新赋值为初始化时间片（具体操作见clk.c中的system_beat_processing()函数，该函数会在每个系统节拍被调用一次，至于任务的切换则是通过在该函数中调用task_yield_cpu()来实现的）。

## 4、API接口
* 1、void switch_task(void)

    功能：主动进行一次任务切换，调度器会找到当前系统最高优先级的任务并运行
    
    数入：无

    返回：无

* 2、void add_task_to_ready_list(struct task_struct_t *task)

    功能：将一个任务添加到就绪任务列表

    输入：需要添加的任务的任务结构体

    返回：无

* 3、void del_task_to_ready_list(struct task_struct_t *task)

    功能：从就绪任务列表删除一个任务

    输入：需要删除的任务的任务结构体

    返回：无

* 4、struct task_struct_t *get_current_task(void)

    功能：获取当前正在运行的任务

    输入：无

    返回：当前正在运行的任务的任务结构体

* 5、void sch_lock(void)

    功能：给调度器上一次锁（可以用来禁用调度器，防止任务切换）

    输入：无

    返回：无

* 6、void sch_unlock(void)

    功能：给调度器进行一次解锁，功能与sch_lock相反

    输入：无

    返回：无

* 7、uint32_t get_sch_lock_level(void)

    功能：获取调度器的上锁等级，调度器每上一次锁该数值加1，只有当该数值为0时调度器才能进行任务调度

    输入：无

    返回：调度器的上锁等级


